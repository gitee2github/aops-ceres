#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import json
from unittest import mock

from ceres.function.status import PARAM_ERROR, SUCCESS, TOKEN_ERROR
from ceres.manages.collect_manage import Collect
from ceres.manages.token_manage import TokenManage
from ceres.manages.vulnerability_manage import VulnerabilityManage
from ceres.tests import BaseTestCase


class TestVulnerabilityController(BaseTestCase):
    header = {
        "Content-Type": "application/json; charset=UTF-8"
    }

    header_with_token = {
        "Content-Type": "application/json; charset=UTF-8",
        "access_token": "13965d8302b5246a13352680d7c8e602"
    }

    header_with_incorrect_token = {
        "Content-Type": "application/json; charset=UTF-8",
        "access_token": "13965d8302b5246a13352680d7c8e602Ss"
    }

    def setUp(self) -> None:
        TokenManage.set_value('13965d8302b5246a13352680d7c8e602')

    @mock.patch.object(VulnerabilityManage, "repo_set")
    def test_repo_set_should_return_success_when_all_is_right(self, mock_repo_set):
        mock_repo_set.return_value = SUCCESS
        mock_args = {
            "repo_info": {
                "name": "mock_name",
                "dest": "mock_dest",
                "repo_content": "mock_content"
            },
            "check_items": [],
            "check": False
        }
        response = self.client.post('v1/ceres/cve/repo/set',
                                    data=json.dumps(mock_args),
                                    headers=self.header_with_token)
        self.assertEqual(SUCCESS, response.json.get('code'))

    def test_repo_set_should_return_token_error_when_token_is_incorrect(self):
        mock_args = {
            "repo_info": {
                "name": "mock_name",
                "dest": "mock_dest",
                "repo_content": "mock_content"
            },
            "check_items": [],
            "check": False
        }
        response = self.client.post('v1/ceres/cve/repo/set',
                                    data=json.dumps(mock_args),
                                    headers=self.header_with_incorrect_token)
        self.assertEqual(TOKEN_ERROR, response.json.get('code'))

    def test_repo_set_should_return_param_error_when_input_args_is_null(self):
        response = self.client.post('v1/ceres/cve/repo/set',
                                    headers=self.header_with_token)
        self.assertEqual(PARAM_ERROR, response.json.get('code'))

    def test_repo_set_should_return_400_when_input_with_no_token(self):
        mock_args = {
            "repo_info": {
                "name": "mock_name",
                "dest": "mock_dest",
                "repo_content": "mock_content"
            },
            "check_items": [],
            "check": False
        }
        response = self.client.post('v1/ceres/cve/repo/set',
                                    data=json.dumps(mock_args),
                                    headers=self.header)
        self.assert400(response)

    @mock.patch.object(VulnerabilityManage, "repo_set")
    def test_repo_set_should_return_param_error_when_input_args_is_incorrect(self, mock_repo_set):
        mock_repo_set.return_value = SUCCESS
        mock_args = {
            "repo_info": {
                "name": "mock_name",
                "dest": "",
                "repo_content": "mock_content"
            },
            "check_items": [],
            "check": False
        }
        response = self.client.post('v1/ceres/cve/repo/set',
                                    data=json.dumps(mock_args),
                                    headers=self.header_with_token)
        self.assertEqual(PARAM_ERROR, response.json.get('code'))

    @mock.patch.object(Collect, "get_system_info")
    @mock.patch.object(Collect, "get_installed_packages")
    @mock.patch.object(VulnerabilityManage, "cve_scan")
    def test_vulnerability_cve_scan_should_return_cve_info_with_installed_packages_when_all_is_right(
            self, mock_cve_scan, mock_installed_packages, mock_system_version):
        mock_args = {
            "basic": True,
            "check_items": [],
            "check": False
        }
        mock_cve_info = ['CVEID1', 'CVEID2']
        mock_system_version.return_value = "openEuler 20.03 LTS"
        mock_installed_packages.return_value = ["mock_pkg1", "mock_pkg2", "mock_pkg3"]
        mock_cve_scan.return_value = SUCCESS, mock_cve_info
        expect_res = {
            'cves': ['CVEID1', 'CVEID2'],
            'installed_packages': ['mock_pkg1', 'mock_pkg2', 'mock_pkg3'],
            'os_version': 'openEuler 20.03 LTS'
        }
        response = self.client.post('v1/ceres/cve/scan',
                                    data=json.dumps(mock_args),
                                    headers=self.header_with_token)
        self.assertEqual(expect_res, response.json.get('result'))

    def test_vulnerability_cve_scan_should_return_400_when_request_with_no_token(self):
        mock_args = {
            "basic": True,
            "check_items": [],
            "check": False
        }
        response = self.client.post('v1/ceres/cve/scan',
                                    data=json.dumps(mock_args),
                                    headers=self.header)
        self.assert400(response)

    def test_vulnerability_cve_scan_should_return_param_error_when_request_with_no_args(self):
        response = self.client.post('v1/ceres/cve/scan', headers=self.header_with_token)
        self.assertEqual(PARAM_ERROR, response.json.get('code'))

    def test_vulnerability_cve_scan_should_return_token_error_when_request_with_incorrect_token(
            self):
        mock_args = {
            "basic": True,
            "check_items": [],
            "check": False
        }
        response = self.client.post('v1/ceres/cve/scan',
                                    data=json.dumps(mock_args),
                                    headers=self.header_with_incorrect_token)
        self.assertEqual(TOKEN_ERROR, response.json.get('code'))

    def test_vulnerability_cve_scan_should_return_400_when_request_with_incorrect_args(self):
        mock_args = {
            "basic": True,
            "check_items": True,
            "check": False
        }
        response = self.client.post('v1/ceres/cve/scan',
                                    data=json.dumps(mock_args),
                                    headers=self.header_with_token)
        self.assert400(response)

    def test_vulnerability_cve_scan_should_return_405_when_request_with_incorrect_method(self):
        mock_args = {
            "basic": True,
            "check_items": [],
            "check": False
        }
        response = self.client.get('v1/ceres/cve/scan',
                                   data=json.dumps(mock_args),
                                   headers=self.header_with_token)
        self.assert_405(response)

    @mock.patch.object(VulnerabilityManage, "cve_fix")
    def test_vulnerability_cve_fix_should_return_cve_fix_result_when_all_is_right(self,
                                                                                  mock_cve_fix):
        mock_cve_fix.return_value = SUCCESS, [
            {
                "cve_id": "cve_2022_xxx1",
                "result": "fixed",
                "log": "fix succeed"
            },
            {
                "cve_id": "cve_2022_xxx2",
                "result": "unfixed",
                "log": "fix fail"
            }]
        mock_args = {
            "check": True,
            "check_items": [],
            "cves": ["cve_2022_xxx1", "cve_2022_xxx2"]
        }
        response = self.client.post('/v1/ceres/cve/fix', data=json.dumps(mock_args),
                                    headers=self.header_with_token)
        self.assertEqual(mock_cve_fix.return_value[1], response.json.get('result'))

    def test_cve_fix_should_return_token_error_when_token_is_incorrect(self):
        mock_args = {
            "check": True,
            "check_items": [],
            "cves": ["cve_2022_xxx1", "cve_2022_xxx2"]
        }
        response = self.client.post('v1/ceres/cve/fix',
                                    data=json.dumps(mock_args),
                                    headers=self.header_with_incorrect_token)
        self.assertEqual(TOKEN_ERROR, response.json.get('code'))

    def test_cve_fix_should_return_400_when_request_with_no_token(self):
        mock_args = {
            "check": True,
            "check_items": [],
            "cves": ["cve_2022_xxx1", "cve_2022_xxx2"]
        }
        response = self.client.post('v1/ceres/cve/fix',
                                    data=json.dumps(mock_args),
                                    headers=self.header)
        self.assert400(response)

    def test_cve_fix_should_return_param_error_when_request_args_is_incorrect(self):
        mock_args = {
            "check": True,
            "check_items": [],
            "cves": [1234, "cve1"]
        }
        response = self.client.post('v1/ceres/cve/fix',
                                    data=json.dumps(mock_args),
                                    headers=self.header_with_token)
        self.assertEqual(PARAM_ERROR, response.json.get('code'))

    def test_cve_fix_should_return_param_error_when_request_with_no_args(self):
        response = self.client.post('v1/ceres/cve/fix',
                                    headers=self.header_with_token)
        self.assertEqual(PARAM_ERROR, response.json.get('code'))

    def test_cve_fix_should_return_405_when_request_with_incorrect_method(self):
        mock_args = {
            "check": True,
            "check_items": [],
            "cves": ["cve_2022_xxx1", "cve_2022_xxx2"]
        }
        response = self.client.get('v1/ceres/cve/scan',
                                   data=json.dumps(mock_args),
                                   headers=self.header_with_token)
        self.assert405(response)
