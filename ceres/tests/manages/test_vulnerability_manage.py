#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import os
from unittest import mock

from ceres.function.status import (
    PARAM_ERROR,
    REPO_CONTENT_INCORRECT,
    REPO_NOT_SET,
    SERVICE_NOT_EXIST,
    SUCCESS
)
from ceres.manages.vulnerability_manage import VulnerabilityManage
from ceres.models.custom_exception import InputError
from ceres.tests import BaseTestCase


class TestVulnerabilityManage(BaseTestCase):
    @mock.patch.object(os, "remove")
    @mock.patch("builtins.open", mock.mock_open())
    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_repo_set_should_return_success_when_input_repo_content_can_be_used_by_yum(
            self, mock_validate_source, mock_remove):
        mock_validate_source.return_value = True
        mock_remove.return_value = ''
        mock_args = {
            "repo_info": {
                "repo_name": "mock_name",
                "dest": "/etc/yum.repos.d/mock.repo",
                "repo_content": "mock_content"
            },
            "check_items": [],
            "check": False
        }
        result = VulnerabilityManage().repo_set(mock_args)
        self.assertEqual(SUCCESS, result)

    @mock.patch.object(os, "remove")
    @mock.patch("builtins.open", mock.mock_open())
    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_repo_set_should_return_repo_content_is_incorrect_when_repo_content_cannot_be_used_by_yum(
            self, mock_validate_source, mock_remove):
        mock_validate_source.return_value = False
        mock_remove.return_value = ''
        mock_args = {
            "repo_info": {
                "repo_name": "mock_name",
                "dest": "/etc/yum.repos.d/mock.repo",
                "repo_content": "mock_content",
                "check": False
            },
            "check_items": []
        }
        result = VulnerabilityManage().repo_set(mock_args)
        self.assertEqual(REPO_CONTENT_INCORRECT, result)

    def test_repo_set_should_return_param_error_when_repo_save_path_is_incorrect(self):
        mock_args = {
            "repo_info": {
                "repo_name": "mock_name",
                "dest": "mock_dest",
                "repo_content": "mock_content",
                "check": False
            },
            "check_items": []
        }
        result = VulnerabilityManage().repo_set(mock_args)
        self.assertEqual(PARAM_ERROR, result)

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_validate_repo_source_should_return_true_when_query_repo_info_succeed(self, mock_shell):
        mock_shell.return_value = ""
        result = VulnerabilityManage._validate_repo_source('update')
        self.assertEqual(True, result)

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_validate_repo_source_should_return_false_when_query_repo_info_fail(self, mock_shell):
        mock_shell.return_value = "Error:Unknown repo: 'update'"
        result = VulnerabilityManage._validate_repo_source('update')
        self.assertEqual(False, result)

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_validate_repo_source_should_return_false_when_shell_command_execute_failed(self, mock_shell):
        mock_shell.side_effect = InputError('')
        self.assertEqual(False, VulnerabilityManage._validate_repo_source('update'))

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_cve_scan_should_return_cve_info_with_package_list_when_all_is_right(
            self, mock_validate_repo, mock_shell):
        mock_validate_repo.return_value = True
        mock_args = {"basic": True}
        mock_cve_info = """
        CVE-2021-35937 Important/Sec. rpm-libs-4.17.0-14.oe2203.x86_64
        CVE-2021-35939 Important/Sec. rpm-libs-4.17.0-14.oe2203.x86_64
        """
        mock_shell.return_value = mock_cve_info
        expected_result = (200, ['CVE-2021-35937', 'CVE-2021-35939'])
        self.assertEqual(expected_result, VulnerabilityManage().cve_scan(mock_args))

    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_cve_scan_should_return_repo_not_set_when_repo_named_update_is_not_set(
            self, mock_validate_repo):
        mock_validate_repo.return_value = False
        mock_args = {"basic": True}
        self.assertEqual(REPO_NOT_SET, VulnerabilityManage().cve_scan(mock_args)[0])

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_cve_scan_should_return_service_not_exist_when_query_cve_fail(
            self, mock_validate_repo, mock_shell):
        mock_validate_repo.return_value = True
        mock_shell.side_effect = InputError('')
        mock_args = {"basic": False}
        self.assertEqual(SERVICE_NOT_EXIST, VulnerabilityManage().cve_scan(mock_args)[0])

    @mock.patch.object(VulnerabilityManage, '_validate_repo_source')
    @mock.patch.object(VulnerabilityManage, '_fix_cve_by_yum')
    def test_cve_fix_should_return_fix_result_when_repo_is_set(self, mock_cve_fix,
                                                               mock_repo_validate):
        mock_repo_validate.return_value = True
        mock_cve_fix.side_effect = [(True, 'fix succeed'), (False, 'command_error')]
        mock_cve = ['cve_id_1', "cve_id_2"]
        expected_result = [{
            "cve_id": "cve_id_1",
            "result": "succeed",
            "log": "fix succeed"
        }, {
            "cve_id": "cve_id_2",
            "result": "fail",
            "log": "command_error"
        }]
        self.assertEqual((SUCCESS, expected_result), VulnerabilityManage().cve_fix(mock_cve))

    @mock.patch.object(VulnerabilityManage, '_validate_repo_source')
    def test_cve_fix_should_return_repo_not_set_when_repo_is_not_set(self, mock_repo_validate):
        mock_repo_validate.return_value = False
        mock_cve = ['cve_id_1', "cve_id_2"]
        expected_result = [{
            "cve_id": "cve_id_1",
            "result": "fail",
            "log": "repo source named aops-update is not set"
        }, {
            "cve_id": "cve_id_2",
            "result": "fail",
            "log": "repo source named aops-update is not set"
        }]
        self.assertEqual((REPO_NOT_SET, expected_result), VulnerabilityManage().cve_fix(mock_cve))

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_check_cve_by_yum_should_return_cve_list_when_command_execute_succeed(self, mock_shell):
        mock_shell.return_value = """
        CVE-2021-46848 Critical/Sec.  libtasn1-4.17.0-3.oe2203.x86_64
        CVE-2022-44638 Important/Sec. pixman-0.40.0-3.oe2203.x86_64
        CVE-2021-35937 Important/Sec. python3-rpm-4.17.0-14.oe2203.x86_64
        """
        expected_result = ["CVE-2021-46848", "CVE-2022-44638", "CVE-2021-35937"]
        self.assertEqual((SUCCESS, expected_result), VulnerabilityManage._check_cve_by_yum(''))

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_check_cve_by_yum_should_return_empty_cve_list_when_command_execute_fail(self, mock_shell):
        mock_shell.side_effect = InputError('')
        self.assertEqual((SERVICE_NOT_EXIST, []), VulnerabilityManage._check_cve_by_yum(''))

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_fix_cve_by_yum_should_return_true_when_execute_command_successfully(self, mock_shell):
        mock_shell.return_value = "Complete"
        self.assertEqual((True, 'Complete'), VulnerabilityManage()._fix_cve_by_yum(''))

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_fix_cve_by_yum_should_return_false_when_execute_command_fail(self, mock_shell):
        mock_shell.return_value = "command error"
        self.assertEqual((False, "command error"), VulnerabilityManage()._fix_cve_by_yum(''))

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_fix_cve_by_yum_should_return_false_when_host_has_no_command_yum(self, mock_shell):
        mock_shell.side_effect = InputError('')
        self.assertEqual((False, "Host has no command yum"),
                         VulnerabilityManage()._fix_cve_by_yum(''))
