#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import os
from unittest import mock

from ceres.function.status import (
    PARAM_ERROR,
    REPO_CONTENT_INCORRECT,
    REPO_NOT_SET,
    SERVICE_NOT_EXIST,
    SUCCESS
)
from ceres.manages.vulnerability_manage import VulnerabilityManage
from ceres.models.custom_exception import InputError
from ceres.tests import BaseTestCase


class TestVulnerabilityManage(BaseTestCase):
    @mock.patch.object(os, "remove")
    @mock.patch("builtins.open", mock.mock_open())
    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_repo_set_should_return_success_when_input_repo_content_can_be_used_by_yum(
            self, mock_validate_source, mock_remove):
        mock_validate_source.return_value = True
        mock_remove.return_value = ''
        mock_args = {
            "repo_info": {
                "repo_name": "mock_name",
                "dest": "/etc/yum.repos.d/mock.repo",
                "repo_content": "mock_content"
            },
            "check_items": [],
            "check": False
        }
        result = VulnerabilityManage().repo_set(mock_args)
        self.assertEqual(SUCCESS, result)

    @mock.patch.object(os, "remove")
    @mock.patch("builtins.open", mock.mock_open())
    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_repo_set_should_return_repo_content_is_incorrect_when_repo_content_cannot_be_used_by_yum(
            self, mock_validate_source, mock_remove):
        mock_validate_source.return_value = False
        mock_remove.return_value = ''
        mock_args = {
            "repo_info": {
                "repo_name": "mock_name",
                "dest": "/etc/yum.repos.d/mock.repo",
                "repo_content": "mock_content",
                "check": False
            },
            "check_items": []
        }
        result = VulnerabilityManage().repo_set(mock_args)
        self.assertEqual(REPO_CONTENT_INCORRECT, result)

    def test_repo_set_should_return_param_error_when_repo_save_path_is_incorrect(self):
        mock_args = {
            "repo_info": {
                "repo_name": "mock_name",
                "dest": "mock_dest",
                "repo_content": "mock_content",
                "check": False
            },
            "check_items": []
        }
        result = VulnerabilityManage().repo_set(mock_args)
        self.assertEqual(PARAM_ERROR, result)

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_validate_repo_source_should_return_true_when_query_repo_info_succeed(self, mock_shell):
        mock_shell.return_value = ""
        result = VulnerabilityManage._validate_repo_source('update')
        self.assertEqual(True, result)

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    def test_validate_repo_source_should_return_false_when_query_repo_info_fail(self, mock_shell):
        mock_shell.return_value = "Error:Unknown repo: 'update'"
        result = VulnerabilityManage._validate_repo_source('update')
        self.assertEqual(False, result)

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_cve_scan_should_return_cve_info_with_package_list_when_all_is_right(
            self, mock_validate_repo, mock_shell):
        mock_validate_repo.return_value = True
        mock_args = {"basic": True}
        mock_cve_info = """
        CVE-2021-35937 Important/Sec. rpm-libs-4.17.0-14.oe2203.x86_64
        CVE-2021-35939 Important/Sec. rpm-libs-4.17.0-14.oe2203.x86_64
        """
        mock_shell.return_value = mock_cve_info
        expected_result = (200, ['CVE-2021-35937', 'CVE-2021-35939'])
        self.assertEqual(expected_result, VulnerabilityManage().cve_scan(mock_args))

    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_cve_scan_should_return_repo_not_set_when_repo_named_update_is_not_set(
            self, mock_validate_repo):
        mock_validate_repo.return_value = False
        mock_args = {"basic": True}
        self.assertEqual(REPO_NOT_SET, VulnerabilityManage().cve_scan(mock_args)[0])

    @mock.patch('ceres.manages.vulnerability_manage.get_shell_data')
    @mock.patch.object(VulnerabilityManage, "_validate_repo_source")
    def test_cve_scan_should_return_service_not_exist_when_query_cve_fail(
            self, mock_validate_repo, mock_shell):
        mock_validate_repo.return_value = True
        mock_shell.side_effect = InputError('')
        mock_args = {"basic": True}
        self.assertEqual(SERVICE_NOT_EXIST, VulnerabilityManage().cve_scan(mock_args)[0])
