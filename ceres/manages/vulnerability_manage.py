#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import os
import re
from typing import List, Tuple

from ceres.conf.constant import REPO_ID_FOR_CVE_MANAGE
from ceres.function.log import LOGGER
from ceres.function.status import (
    PARAM_ERROR,
    REPO_CONTENT_INCORRECT,
    REPO_NOT_SET,
    SERVICE_NOT_EXIST,
    SUCCESS,
    StatusCode,
    COMMANDS_ERROR
)
from ceres.function.util import get_shell_data
from ceres.models.custom_exception import InputError


class VulnerabilityManage:
    def repo_set(self, data: dict) -> int:
        """
        Save the repo source to local, and do simple verification.

        Args:
            data (dict): e.g
                {
                    "repo_info": {
                        "name": "string",
                        "dest": "save location",
                        "repo_content": "repo source info"
                    },
                    "check_items": ["string"],
                    "check": false
                }

        Returns:
            int: status code
        """
        repo_path = data.get("repo_info").get("dest")
        if re.match(r"/etc/yum.repos.d/[\w-]+.repo$", repo_path) is None:
            LOGGER.debug('Incorrect repo save path.')
            return PARAM_ERROR

        content = data.get("repo_info").get("repo_content")
        with open(repo_path, 'w', encoding='utf8') as repo_file:
            repo_file.write(content)
            LOGGER.info(f'Repo source {data.get("repo_info").get("name")} '
                        f'has been saved to {repo_path}.')

        if self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            LOGGER.info('Repo source set succeed.')
            return SUCCESS
        os.remove(data.get("repo_info").get("dest"))
        LOGGER.warning("Repo source can't be used, it has been deleted.")
        return REPO_CONTENT_INCORRECT

    @staticmethod
    def _validate_repo_source(repo_id: str) -> bool:
        """
        A sample validate which repo can used by yum.

        Args:
            repo_id(str): repo id

        Returns:
            bool
        """
        try:
            repo_info = get_shell_data(["yum", "repoinfo", "--repo", repo_id])
        except InputError:
            repo_info = 'Error'
        return "Error" not in repo_info

    def cve_scan(self, cve_scan_args: dict) -> Tuple[int, dict]:
        """
        Scan CVEs in the machine

        Args:
            cve_scan_args(dict): e.g
                {
                    basic: true,
                    check: true,
                    check_items: []
                }
            basic: true, Determine whether to scan CVE by dnf or scan CVE by scanning tool
            check: whether to perform check works.
            check_items: Items that need to be checked before execution.

        Returns:
            int: status code
            dict: e.g
                list: e.g
                {"unfixed_cves":[
                        {"cve_id": "CVE-1-1",
                         "hotpatch": True},
                        {"cve_id": "CVE-1-2",
                        "hotpatch": False}
                        ],
                "fixed_cves":[
                        {"cve_id": "CVE-10-10",
                         "fixed_by_hp": True},
                        {"cve_id": "CVE-11-21",
                        "fixed_by_hp": False}
                        ]
                }
        """
        if self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            if cve_scan_args.get('basic') is True:
                return self._check_cve_by_dnf(REPO_ID_FOR_CVE_MANAGE)
            return SERVICE_NOT_EXIST, {}

        LOGGER.warning(f'Failed to query repo basic info '
                       f'which repo id is {REPO_ID_FOR_CVE_MANAGE}.')
        return REPO_NOT_SET, {}

    @staticmethod
    def _check_cve_by_dnf(repo_id: str) -> Tuple[int, dict]:
        """
        Detect which CVEs can be fixed from the update source

        Args:
            repo_id(str): repo id

        Returns:
            int: status code
            dict: e.g
                list: e.g
                {"unfixed_cves":[
                        {"cve_id": "CVE-1-1",
                         "hotpatch": True},
                        {"cve_id": "CVE-1-2",
                        "hotpatch": False}
                        ],
                "fixed_cves":[
                        {"cve_id": "CVE-10-10",
                         "fixed_by_hp": True},
                        {"cve_id": "CVE-11-21",
                        "fixed_by_hp": False}
                        ]
                }
        """
        result_dict = {"unfixed_cves": [], "fixed_cves": []}

        try:
            unfixed_cves = get_shell_data(
                ["dnf", "hotpatch", "--list"])
            support_hp = True
        except InputError:
            LOGGER.error("Failed to get cve list from dnf")
            return COMMANDS_ERROR, result_dict
        if "No such command: hotpatch" in unfixed_cves:
            unfixed_cves = get_shell_data(
                ["dnf", "updateinfo", "list", "cves", "--repo", repo_id])
            support_hp = False
        # unfixed_cves e.g.
        # Last metadata expiration check: 4:31:51 ago on Tue 09 May 2023 05:50:28 AM CST.
        # CVE-2021-32675 Low/sec.- -
        for scan_info in unfixed_cves.strip().split("\n"):
            # The standard data format is CVE-2021-32675 Low/sec. --
            if scan_info[:4] == "CVE-":
                cve = re.findall(r"CVE-[\d]{4}-[\d]+", scan_info)[0]
                result_dict["unfixed_cves"].append({
                    "cve_id": cve,
                    "hotpatch": scan_info[-1] != "-" if support_hp else False
                })

        # Get fixed CVE
        # cold patch
        try:
            cold_patch_fixed_result = get_shell_data(
                ["dnf", "updateinfo", "--list", "cves", "--installed"]
            )
        except InputError:
            LOGGER.error("Failed to get cold patch fixed cve from dnf")
            return COMMANDS_ERROR, result_dict
        # cold_patch_fixed_result e.g.
        # Last metadata expiration check: 0:04:47 ago on Fri 12 May 2023 09:19:38 AM CST.
        # CVE-2022-3080   Important/Sec. bind-libs-9.16.23-11.oe2203.aarch64
        for cold_patch_fixed in cold_patch_fixed_result.strip().split("\n")[1:]:
            cold_patch_fixed_split = cold_patch_fixed.split(" ")
            result_dict["fixed_cves"].append({
                "cve_id": cold_patch_fixed_split[0],
                "fixed_by_hp": False
            })

        # hotpatch
        try:
            hotpatch_fixed_result = get_shell_data(
                ["dnf", "hotpatch", "list", "cves"]
            )
        except InputError:
            LOGGER.error("Failed to get hotpatch fixed cve from dnf")
            return COMMANDS_ERROR, result_dict

        # hotpatch_fixed_result e.g.
        # Last metadata expiration check: 0:04:47 ago on Fri 12 May 2023 09:19:38 AM CST.
        # CVE-2022-3080   A-1.1-1/HP3    ACTIVED
        for hotpatch_fixed in hotpatch_fixed_result.strip().split("\n")[1:]:
            hotpatch_fixed_split = hotpatch_fixed.split(" ")
            if hotpatch_fixed_split[-1] in ["ACTIVED", "ACCEPT"]:
                result_dict["fixed_cves"].append({
                    "cve_id": hotpatch_fixed_split[0],
                    "fixed_by_hp": True
                })

        return SUCCESS, result_dict

    def cve_fix(self, cves: List[dict]) -> Tuple[int, list]:
        """
        fix cve

        Args:
            cves(list): cve list which need to fix,e.g.
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True},
                {
                    "cve_id": "CVE-1-2",
                    "hotpatch": False},
                }]

        Returns:
            int: status code
            list: e.g
                [{
                    "cve_id": cve,
                    "result": "succeed",
                    "log": "fix succeed"
                }]

        """
        result_list = []
        if not self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            for cve in cves:
                result_list.append({
                    "cve_id": cve.get("cve_id"),
                    "log": StatusCode.mapping.get(REPO_NOT_SET).get('msg'),
                    "result": 'fail'
                })
            return REPO_NOT_SET, result_list

        for cve in cves:
            command_execute_result = self._fix_cve_by_dnf(cve)
            result = {
                "cve_id": cve.get("cve_id"),
                "log": command_execute_result[1],
                "result": 'succeed' if command_execute_result[0] else 'fail'
            }
            result_list.append(result)

        return SUCCESS, result_list

    @staticmethod
    def _fix_cve_by_dnf(cve: dict) -> Tuple[bool, str]:
        """
        Fix CVE by dnf based on repo source named update

        Args:
            cve(dict): CVE ID and hotpatch, e.g.
                {"cve_id": "CVE-1-1",
                "hotpatch": True}

        Returns:
            bool: True or False
            command_execute_result: output from command execution

        """
        hotpatch = cve.get("hotpatch")
        if hotpatch:
            commond_args = ["dnf", "hotupgrade",
                            f"--cve={cve.get('cve_id')}", "-y"]
        else:
            commond_args = ["dnf", "update",
                            f"--cve={cve.get('cve_id')}", "-y"]
        try:
            res = get_shell_data(commond_args)
        except InputError:
            LOGGER.error(f"Failed to fix cve {cve.get('cve_id')} by dnf")
            res = 'Host has no command dnf'

        if hotpatch:
            return "Apply hot patch succeed" in res, res
        else:
            return "Complete" in res, res
