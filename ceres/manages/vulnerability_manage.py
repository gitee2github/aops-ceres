#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import os
import re
from typing import List, Tuple

from ceres.conf.constant import REPO_ID_FOR_CVE_MANAGE
from ceres.function.log import LOGGER
from ceres.function.status import (
    PARAM_ERROR,
    REPO_CONTENT_INCORRECT,
    REPO_NOT_SET,
    SERVICE_NOT_EXIST,
    SUCCESS,
    StatusCode
)
from ceres.function.util import get_shell_data
from ceres.models.custom_exception import InputError


class VulnerabilityManage:
    def repo_set(self, data: dict) -> int:
        """
        Save the repo source to local, and do simple verification.

        Args:
            data (dict): e.g
                {
                    "repo_info": {
                        "name": "string",
                        "dest": "save location",
                        "repo_content": "repo source info"
                    },
                    "check_items": ["string"],
                    "check": false
                }

        Returns:
            int: status code
        """
        repo_path = data.get("repo_info").get("dest")
        if re.match(r"/etc/yum.repos.d/[\w-]+.repo$", repo_path) is None:
            LOGGER.debug('Incorrect repo save path.')
            return PARAM_ERROR

        content = data.get("repo_info").get("repo_content")
        with open(repo_path, 'w', encoding='utf8') as repo_file:
            repo_file.write(content)
            LOGGER.info(f'Repo source {data.get("repo_info").get("name")} '
                        f'has been saved to {repo_path}.')

        if self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            LOGGER.info('Repo source set succeed.')
            return SUCCESS
        os.remove(data.get("repo_info").get("dest"))
        LOGGER.warning("Repo source can't be used, it has been deleted.")
        return REPO_CONTENT_INCORRECT

    @staticmethod
    def _validate_repo_source(repo_id: str) -> bool:
        """
        A sample validate which repo can used by yum.

        Args:
            repo_id(str): repo id

        Returns:
            bool
        """
        try:
            repo_info = get_shell_data(["yum", "repoinfo", "--repo", repo_id])
        except InputError:
            repo_info = 'Error'
        return "Error" not in repo_info

    def cve_scan(self, cve_scan_args: dict) -> Tuple[int, list]:
        """
        Scan CVEs in the machine

        Args:
            cve_scan_args(dict): e.g
                {
                    basic: true,
                    check: true,
                    check_items: []
                }
            basic: true, Determine whether to scan CVE by dnf or scan CVE by scanning tool
            check: whether to perform check works.
            check_items: Items that need to be checked before execution.

        Returns:
            int: status code
            list: e.g
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True},
                {
                    "cve_id": "CVE-1-2",
                    "hotpatch": False},
                }]
        """
        if self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            if cve_scan_args.get('basic') is True:
                return self._check_cve_by_dnf(REPO_ID_FOR_CVE_MANAGE)
            return SERVICE_NOT_EXIST, []

        LOGGER.warning(f'Failed to query repo basic info '
                       f'which repo id is {REPO_ID_FOR_CVE_MANAGE}.')
        return REPO_NOT_SET, []

    @staticmethod
    def _check_cve_by_dnf(repo_id: str) -> Tuple[int, list]:
        """
        Detect which CVEs can be fixed from the update source

        Args:
            repo_id(str): repo id

        Returns:
            int: status code
            list: e.g
                list: e.g
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True},
                {
                    "cve_id": "CVE-1-2",
                    "hotpatch": False},
                }]
        """
        result_list = []
        # cves = set()

        try:
            scan_result = get_shell_data(
                ["dnf", "hotpatch", "--list"])
            is_dnf_command = True
        except InputError:
            LOGGER.error("Failed to get cve list from dnf")
            return SERVICE_NOT_EXIST, []
        if (not scan_result) or ("No such command: hotpatch" in scan_result):
            scan_result = get_shell_data(
                ["dnf", "updateinfo", "list", "cves", "--repo", repo_id])
            is_dnf_command = False

        for scan_info in scan_result.strip().split("\n")[2:]:
            cve = re.findall(r"CVE-[\d]{4}-[\d]+", scan_info)[0]
            # if cve in cves:
            #     continue
            # cves.add(cve)
            result_list.append({
                "cve_id": cve,
                "hotpatch": scan_info[-1] != "-" if is_dnf_command else False
            })

        return SUCCESS, result_list

    def cve_fix(self, cves: List[dict]) -> Tuple[int, list]:
        """
        fix cve

        Args:
            cves(list): cve list which need to fix,e.g.
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True},
                {
                    "cve_id": "CVE-1-2",
                    "hotpatch": False},
                }]

        Returns:
            int: status code
            list: e.g
                [{
                    "cve_id": cve,
                    "result": "succeed",
                    "log": "fix succeed"
                }]

        """
        result_list = []
        if not self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            for cve in cves:
                result_list.append({
                    "cve_id": cve.get("cve_id"),
                    "log": StatusCode.mapping.get(REPO_NOT_SET).get('msg'),
                    "result": 'fail'
                })
            return REPO_NOT_SET, result_list

        for cve in cves:
            command_execute_result = self._fix_cve_by_dnf(cve)
            result = {
                "cve_id": cve.get("cve_id"),
                "log": command_execute_result[1],
                "result": 'succeed' if command_execute_result[0] else 'fail'
            }
            result_list.append(result)

        return SUCCESS, result_list

    @staticmethod
    def _fix_cve_by_dnf(cve: dict) -> Tuple[bool, str]:
        """
        Fix CVE by dnf based on repo source named update

        Args:
            cve(dict): CVE ID and hotpatch, e.g.
                {"cve_id": "CVE-1-1",
                "hotpatch": True}

        Returns:
            bool: True or False
            command_execute_result: output from command execution

        """
        if cve.get("hotpatch"):
            commond_args = ["dnf", "hotpatch", f"--cve={cve.get('cve_id')}"]
        else:
            commond_args = ["dnf", "update", f"--cve={cve.get('cve_id')}"]
        try:
            res = get_shell_data(commond_args)
        except InputError:
            LOGGER.error(f"Failed to fix cve {cve.get('cve_id')} by dnf")
            res = 'Host has no command dnf'

        return "Apply hot patch succeed" in res, res
