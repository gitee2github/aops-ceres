#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import os
import re
from collections import defaultdict
from typing import List, Tuple

from ceres.conf.constant import REPO_ID_FOR_CVE_MANAGE
from ceres.function.log import LOGGER
from ceres.function.status import (
    NO_COMMAND,
    NOT_PATCH,
    PARAM_ERROR,
    REPO_CONTENT_INCORRECT,
    REPO_NOT_SET,
    SERVICE_NOT_EXIST,
    SUCCESS,
    StatusCode,
    COMMAND_EXEC_ERROR
)
from ceres.function.util import get_shell_data, cmd_output
from ceres.models.custom_exception import InputError

SUCCEED = 0
FAIL = 255


class VulnerabilityManage:
    def repo_set(self, data: dict) -> int:
        """
        Save the repo source to local, and do simple verification.

        Args:
            data (dict): e.g
                {
                    "repo_info": {
                        "name": "string",
                        "dest": "save location",
                        "repo_content": "repo source info"
                    },
                    "check_items": ["string"],
                    "check": false
                }

        Returns:
            int: status code
        """
        repo_path = data.get("repo_info").get("dest")
        if re.match(r"/etc/yum.repos.d/[\w-]+.repo$", repo_path) is None:
            LOGGER.debug('Incorrect repo save path.')
            return PARAM_ERROR

        content = data.get("repo_info").get("repo_content")
        with open(repo_path, 'w', encoding='utf8') as repo_file:
            repo_file.write(content)
            LOGGER.info(f'Repo source {data.get("repo_info").get("name")} '
                        f'has been saved to {repo_path}.')

        if self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            LOGGER.info('Repo source set succeed.')
            return SUCCESS
        os.remove(data.get("repo_info").get("dest"))
        LOGGER.warning("Repo source can't be used, it has been deleted.")
        return REPO_CONTENT_INCORRECT

    @staticmethod
    def _validate_repo_source(repo_id: str) -> bool:
        """
        A sample validate which repo can used by yum.

        Args:
            repo_id(str): repo id

        Returns:
            bool
        """
        try:
            repo_info = get_shell_data(["yum", "repoinfo", "--repo", repo_id])
        except InputError:
            repo_info = 'Error'
        return "Error" not in repo_info

    def cve_scan(self, cve_scan_args: dict) -> Tuple[int, dict]:
        """
        Scan CVEs in the machine

        Args:
            cve_scan_args(dict): e.g
                {
                    basic: true,
                    check: true,
                    check_items: []
                }
            basic: true, Determine whether to scan CVE by dnf or scan CVE by scanning tool
            check: whether to perform check works.
            check_items: Items that need to be checked before execution.

        Returns:
            int: status code
            dict: e.g
                list: e.g
                {"unfixed_cves":[
                        {"cve_id": "CVE-1-1",
                         "support_hp": True},
                        {"cve_id": "CVE-1-2",
                        "support_hp": False}
                        ],
                "fixed_cves":[
                        {"cve_id": "CVE-10-10",
                         "fixed_by_hp": True},
                        {"cve_id": "CVE-11-21",
                        "fixed_by_hp": False}
                        ]
                }
        """
        if self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            if cve_scan_args.get('basic') is True:
                return self._check_cve_by_dnf(REPO_ID_FOR_CVE_MANAGE)
            return SERVICE_NOT_EXIST, {}

        LOGGER.warning(f'Failed to query repo basic info '
                       f'which repo id is {REPO_ID_FOR_CVE_MANAGE}.')
        return REPO_NOT_SET, {}

    @staticmethod
    def _check_cve_by_dnf(repo_id: str) -> Tuple[int, dict]:
        """
        Detect which CVEs can be fixed from the update source

        Args:
            repo_id(str): repo id

        Returns:
            int: status code
            dict: e.g
                list: e.g
                {"unfixed_cves":[
                        {"cve_id": "CVE-1-1",
                         "support_hp": True},
                        {"cve_id": "CVE-1-2",
                        "support_hp": False}
                        ],
                "fixed_cves":[
                        {"cve_id": "CVE-10-10",
                         "fixed_by_hp": True},
                        {"cve_id": "CVE-11-21",
                        "fixed_by_hp": False}
                        ]
                }
        """
        result_dict = {"unfixed_cves": [], "fixed_cves": []}

        try:
            unfixed_cves = get_shell_data(["dnf", "hot-updateinfo", "list", "cves"])
            is_hp_command = True
        except InputError:
            LOGGER.error("Failed to get cve list from dnf")
            return COMMAND_EXEC_ERROR, result_dict
        if "No such command: hotpatch" in unfixed_cves:
            unfixed_cves = get_shell_data(["dnf", "updateinfo", "list", "cves", "--repo", repo_id])
            is_hp_command = False
        # unfixed_cves e.g.
        # Last metadata expiration check: 4:31:51 ago on Tue 09 May 2023 05:50:28 AM CST.
        # CVE-2021-32675 Low/sec.- -
        for scan_info in unfixed_cves.strip().split("\n"):
            # The standard data format is CVE-2021-32675 Low/sec. --
            if scan_info[:4] == "CVE-":
                cve = re.findall(r"CVE-[\d]{4}-[\d]+", scan_info)[0]
                result_dict["unfixed_cves"].append({
                    "cve_id": cve,
                    "support_hp": scan_info[-1] != "-" if is_hp_command else False
                })

        # Get fixed CVE
        # cold patch
        try:
            cold_patch_fixed_result = get_shell_data(
                ["dnf", "updateinfo", "list", "cves", "--installed"]
            )
        except InputError:
            LOGGER.error("Failed to get cold patch fixed cve from dnf")
            return COMMAND_EXEC_ERROR, result_dict
        # cold_patch_fixed_result e.g.
        # Last metadata expiration check: 0:04:47 ago on Fri 12 May 2023 09:19:38 AM CST.
        # CVE-2022-3080   Important/Sec. bind-libs-9.16.23-11.oe2203.aarch64
        for cold_patch_fixed in cold_patch_fixed_result.strip().split("\n")[1:]:
            cold_patch_fixed_split = cold_patch_fixed.split(" ")
            result_dict["fixed_cves"].append({
                "cve_id": cold_patch_fixed_split[0],
                "fixed_by_hp": False
            })

        # hotpatch
        try:
            hotpatch_fixed_result = get_shell_data(["dnf", "hotpatch", "--list", "cves"])
        except InputError:
            LOGGER.error("Failed to get hotpatch fixed cve from dnf")
            return COMMAND_EXEC_ERROR, result_dict

        # hotpatch_fixed_result e.g.
        # Last metadata expiration check: 0:04:47 ago on Fri 12 May 2023 09:19:38 AM CST.
        # CVE-2022-3080   A-1.1-1/HP3    ACTIVED
        for hotpatch_fixed in hotpatch_fixed_result.strip().split("\n")[1:]:
            hotpatch_fixed_split = hotpatch_fixed.split(" ")
            if hotpatch_fixed_split[-1] in ["ACTIVED", "ACCEPTED"]:
                result_dict["fixed_cves"].append({
                    "cve_id": hotpatch_fixed_split[0],
                    "fixed_by_hp": True,
                    "hp_status": hotpatch_fixed_split[-1]
                })

        return SUCCESS, result_dict

    def cve_fix(self, cves: List[dict]) -> Tuple[int, list]:
        """
        fix cve

        Args:
            cves(list): cve list which need to fix,e.g.
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True},
                {
                    "cve_id": "CVE-1-2",
                    "hotpatch": False},
                }]

        Returns:
            int: status code
            list: e.g
                [{
                    "cve_id": cve,
                    "result": "succeed",
                    "log": "fix succeed"
                }]

        """
        result_list = []
        if not self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            for cve in cves:
                result_list.append({
                    "cve_id": cve.get("cve_id"),
                    "log": StatusCode.mapping.get(REPO_NOT_SET).get('msg'),
                    "result": 'fail'
                })
            return REPO_NOT_SET, result_list

        for cve in cves:
            command_execute_result = self._fix_cve_by_dnf(cve)
            result = {
                "cve_id": cve.get("cve_id"),
                "log": command_execute_result[1],
                "result": 'succeed' if command_execute_result[0] else 'fail'
            }
            result_list.append(result)

        return SUCCESS, result_list

    def _fix_cve_by_dnf(self, cve: dict) -> Tuple[bool, str]:
        """
        Fix CVE by dnf based on repo source named update

        Args:
            cve(dict): CVE ID and hotpatch, e.g.
                {"cve_id": "CVE-1-1",
                "hotpatch": True}

        Returns:
            bool: True or False
            command_execute_result: output from command execution

        """
        hotpatch = cve.get("hotpatch")
        if hotpatch:
            commond_args = ["dnf", "hotupgrade", f"--cve={cve.get('cve_id')}", "-y"]
        else:
            commond_args = ["dnf", "update", f"--cve={cve.get('cve_id')}", "-y"]
        try:
            res = get_shell_data(commond_args)
        except InputError:
            LOGGER.error(f"Failed to fix cve {cve.get('cve_id')} by dnf")
            res = 'Host has no command dnf'

        if hotpatch:
            hot_pkg = self._hotpatch_list_cve_with_cveid(cve.get('cve_id'))
            if not hot_pkg:
                return False, res
            syscare_res = self._syscare_change_status(hot_pkg, cve.get('accepted'))
            if not syscare_res:
                return False, res
            return "Active/Accept hot patch succeed" in res or "No hot patches marked for install" in res, res
        else:
            return "Complete" in res, res

    def cve_rollback(self, cves: list[dict]) -> Tuple[str, list]:
        """
        cve rollback 

        Args:
            cves(list): cve list which need to rollback,e.g.
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True
                }]

        Returns:
            str: status code
            list: e.g
                [{
                    "cve_id": cve,
                    "result": "succeed",
                    "log": "rollback succeed"
                }]

        """

        if not self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            return REPO_NOT_SET, [dict(cve_id=cve["cve_id"], log=StatusCode.mapping[REPO_NOT_SET]['msg'], result="fail")
                                  for cve in cves]

        return self._cve_rollback(cves)

    def _cve_rollback(self, cves: list[dict]) -> Tuple[str, list]:
        """
        Roll back a restored cve

        Args:
            cves(list): cve list which need to rollback,e.g.
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True
                }]

        Returns:
            str: status code
            list: e.g
                [{
                    "cve_id": cve,
                    "result": "succeed",
                    "log": "rollback succeed"
                }]

        """
        try:
            hotpatch_list = self._hotpatch_list_cve()
        except InputError:
            LOGGER.error(f"Failed to hotpatch list cve.")
            log = "Host has no command dnf hotpatch."
            return NO_COMMAND, [dict(cve_id=cve["cve_id"], log=log, result="fail") for cve in cves]

        if not hotpatch_list:
            log = "No valid hot patch is matched."
            return NOT_PATCH, [dict(cve_id=cve["cve_id"], log=log, result="succeed") for cve in cves]

        cmd_execute_result = []
        for base_pkg, hotpatch_cves in hotpatch_list.items():
            rollback_result, log = self._hotpatch_rollback(base_pkg)
            result = 'succeed' if rollback_result else 'fail'
            cmd_execute_result.extend([dict(cve_id=cve, log=log, result=result) for cve in hotpatch_cves])

        not_rollback_cve = set([cve["cve_id"] for cve in cves]).difference(
            set([cve_info["cve_id"] for cve_info in cmd_execute_result]))

        if not_rollback_cve:
            for cve in [cve for cve in cves if cve["cve_id"] in not_rollback_cve]:
                if cve["hotpatch"]:
                    log = "No valid hot patch is matched."
                else:
                    log = "Cold patch rollback is not supported."
                cmd_execute_result.append(dict(cve_id=cve["cve_id"], log=log, result="fail"))

        return SUCCESS, cmd_execute_result

    @staticmethod
    def _hotpatch_list_cve() -> dict:
        """
        Run the dnf hotpatch list cve command to query the hotpatch list corresponding to the cve

        Returns:
            dict: e.g
                {
                    "base-pkg/hotpatch-1": [cve_id1,cveid2],
                    "base-pkg/hotpatch-2": [cve_id1,cveid2]
                }
        """
        # Run the dnf command to query the hotpatch list,e.g
        # Last metadata expiration check:
        # CVE id   base-pkg/hotpatch  status
        # CVE-1        A-1.1-1/HP1    ACTIVED
        # CVE-2        A-1.1-1/HP1    ACTIVED
        hotpatch_list_output = get_shell_data(["dnf", "hotpatch", "--list", "cve"])
        if not re.search("base-pkg/hotpatch", hotpatch_list_output):
            return None
        hotpatch_list = defaultdict(list)
        for hotpatch_info in [line for line in hotpatch_list_output.split(os.linesep) if line]:
            if not hotpatch_info.startswith("CVE"):
                continue
            cve_id, base_pkg, status = [info.strip() for info in hotpatch_info.split()]
            if status != "ACTIVED" and status != "ACCEPT":
                continue
            hotpatch_list[base_pkg].append(cve_id)

        return hotpatch_list

    @staticmethod
    def _hotpatch_list_cve_with_cveid(cve_id) -> str:
        """
        Run the dnf hotpatch list cve command to query the hotpatch list corresponding to the cve

        Returns:
            str
            e.g.
        """
        # Run the dnf command to query the hotpatch list,e.g
        # Last metadata expiration check:
        # CVE-id        base-pkg/hotpatch   status
        # CVE-2023-1111 redis-6.2.5-1/HP001 ACTIVED
        hotpatch_list_output, status_code = cmd_output(["dnf", "hotpatch", "--list", "cves", "--cve", cve_id])
        if status_code == FAIL or not re.search("base-pkg/hotpatch", hotpatch_list_output):
            return None

        for hotpatch_info in [line for line in hotpatch_list_output.split(os.linesep) if line]:
            if not hotpatch_info.startswith("CVE"):
                continue
            _, hot_pkg, _, = [info.strip() for info in hotpatch_info.split()]
            if hot_pkg == "base-pkg/hotpatch":
                continue
            return hot_pkg
        return ""

    def _syscare_operate(self, operate, patch_name=None):
        """

        """
        _, operate_code = cmd_output(["syscare", "save"])
        if operate_code == FAIL:
            LOGGER.error(f"syscare save failed")
        _, operate_code = cmd_output(["syscare", operate, patch_name])
        if operate_code == FAIL:
            LOGGER.error(f"syscare {operate} {patch_name} failed,start roll back")
            cmd_output(["syscare", "restore"])
            if operate_code == FAIL:
                LOGGER.error(f"syscare restore failed,status roll back failed")
            else:
                LOGGER.info(f"syscare restore success")
            return False
        LOGGER.info(f"syscare {operate} {patch_name} success ")
        return True

    def _syscare_change_status(self, hot_pkg: str, accepted=False):
        """
       Apply hot patch use syscare accept

        Args:
            hot_pkg: cve is rolled back
        """
        res = self._syscare_operate("apply", hot_pkg)
        if not res:
            return False
        res = self._syscare_operate("active", hot_pkg)
        if not res:
            return False
        if accepted:
            res = self._syscare_operate("accept", hot_pkg)
            if not res:
                return False
        return True

    def _hotpatch_rollback(self, base_pkg_hotpatch: str) -> Tuple[bool, str]:
        """
        Hot patch is rolled back

        Args:
            cve_id: cve is rolled back
        """
        execute_result, hotpatch_release_info = self._hotpatch_info(base_pkg_hotpatch)
        if not execute_result:
            return False, "Failed to query patch information."

        hotpatch_name = "patch-%s-%s-%s-%s" % tuple(base_pkg_hotpatch.split("/") + list(hotpatch_release_info.values()))

        return True, get_shell_data(["dnf", "remove", hotpatch_name, "-y"])

    @staticmethod
    def _hotpatch_info(base_pkg_hotpatch: str) -> Tuple[bool, dict]:
        """
        Use syscare to query details about hotpatche

        Args:
            base_pkg_hotpatch: Basic hotpatch package

        Returns:
            bool: result of the command execution
            dict: {
                "version": 1,
                "release": 1
            }
        """

        syscare_info = ["syscare", "info", base_pkg_hotpatch]
        # The standard output of syscare info command

        # syscare info A-1.1-1/HP1
        # uuid:        f4d17141-3356-4a49-a030-45496616e725
        # name:        HP001
        # version:     1
        # release:     1
        # arch:        x86_64
        # type:        UserPatch
        # target:      redis-6.2.5-1
        # target_elf:  redis-server
        # digest:      31fc7544
        # license:     BSD and MIT
        # description: (none)
        # patch:
        # 31fc7544 0001-Prevent-unauthenticated-client-from-easily-consuming.patch

        try:
            hotpatch_info_detail = get_shell_data(syscare_info)
        except InputError:
            LOGGER.error(f"Failed to syacare info.")
            return False, None
        hotpatch_release_info = dict()
        for hotpatch_info in hotpatch_info_detail.split(os.linesep):
            try:
                info_property, info_value = hotpatch_info.split(":")
            except ValueError:
                continue
            if info_property in ["version", "release"]:
                hotpatch_release_info[info_property] = info_value.strip()
        return True, hotpatch_release_info
